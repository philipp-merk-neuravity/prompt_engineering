[
    {
        "task_id": "HumanEval/0",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert not has_close_elements([1.0, 2.0, 3.0], -1.0)",
                "assert not has_close_elements([10000.0, 20000.0, 30000.0], 0.1)",
                "assert has_close_elements([-1.0, -1.2], 0.3)"
            ],
            "failed_tests": [
                "assert has_close_elements([1.0, 1.0], 0.0) (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/1",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert separate_paren_groups('()') == ['()'], \"Test with a single, empty group of parentheses\"",
                "assert separate_paren_groups('((((()))))') == ['((((()))))'], \"Test with a very deeply nested group\"",
                "assert separate_paren_groups('( )(( ))(( )( ))') == ['()', '(())', '(()())'], \"Test with multiple groups, some nested\"",
                "assert separate_paren_groups(' ( ) ( ( ) ) ') == ['()', '(())'], \"Test with interleaved spaces within and outside groups\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/2",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert truncate_number(3.5) == 0.5",
                "assert truncate_number(100.0) == 0.0"
            ],
            "failed_tests": [
                "assert truncate_number(7.333333) == 0.333333 (AssertionError: )",
                "assert truncate_number(5.999999) == 0.999999 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/3",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert below_zero([10, -20, 10, 5]) == True, \"Test with operations that dip below zero then recover\"",
                "assert below_zero([100]) == False, \"Test with a single positive operation\"",
                "assert below_zero([1]*1000) == False, \"Test with a large number of positive operations\"",
                "assert below_zero([5, -2, -4, 1]) == True, \"Test where balance eventually falls below zero\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/4",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0",
                "assert mean_absolute_deviation([1e-9, 1.0, 2.0, 3.0]) == 0.99999999975",
                "assert mean_absolute_deviation([-2.0, -1.0, 0.0, 1.0, 2.0]) == 1.2",
                "assert mean_absolute_deviation([5.0]) == 0.0"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/5",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert intersperse([1], 4) == [1]",
                "assert intersperse([1, 1, 1], 2) == [1, 2, 1, 2, 1]",
                "assert intersperse([1, 2, 3], 0) == [1, 0, 2, 0, 3]",
                "assert intersperse([1, 2, 3], -4) == [1, -4, 2, -4, 3]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/6",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3], \"Multiple groups should return a list of depths\"",
                "assert parse_nested_parens('(((()))) (()()()) (((()))) (())') == [4, 2, 4, 2], \"Complex structures should be accurately parsed\"",
                "assert parse_nested_parens('((((()))))') == [5], \"Deeply nested parentheses should have a depth of 5\"",
                "assert parse_nested_parens('(()) (())') == [2, 2], \"Different structures with the same depth should return the same depths\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/7",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert filter_by_substring(['xyz', 'uvw', '123'], 'a') == []",
                "assert filter_by_substring([], 'a') == []",
                "assert filter_by_substring(['short', 'list'], 'this is a very long substring') == []",
                "assert filter_by_substring(['abc123', 'def456', '789ghi'], '123') == ['abc123']"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/8",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert sum_product([0, -1, -2, -3]) == (-6, 0), \"Test with zeros and negative integers failed.\"",
                "assert sum_product([1, 2, 3, 4]) == (10, 24), \"Test with positive integers failed.\"",
                "assert sum_product(list(range(1, 101))) == (5050, 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000), \"Test with a large list of integers failed.\"",
                "assert sum_product([-1, -2, -3]) == (-6, -6), \"Test with negative integers failed.\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/9",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert rolling_max([7]) == [7], \"Test with a single element list failed.\"",
                "assert rolling_max([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2], \"Test with a constant sequence failed.\"",
                "assert rolling_max([5, 1, 2, 3, 4]) == [5, 5, 5, 5, 5], \"Test with a sequence starting with max failed.\"",
                "assert rolling_max([1, 100, 2, 3, 4]) == [1, 100, 100, 100, 100], \"Test with a large jump in values failed.\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/10",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert is_palindrome('a') == True, \"Single character failed\"",
                "assert is_palindrome('') == True, \"Empty string failed\"",
                "assert make_palindrome('madam') == 'madam', \"Already a palindrome failed\""
            ],
            "failed_tests": [
                "assert make_palindrome('cat!') == 'cat!!tac', \"String with special characters failed\" (AssertionError: String with special characters failed)"
            ]
        }
    },
    {
        "task_id": "HumanEval/11",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert string_xor('11110000', '00001111') == '11111111', \"XOR of half 1s and half 0s should return all 1s\"",
                "assert string_xor('101010', '010101') == '111111', \"XOR of alternating bits should return all 1s\""
            ],
            "failed_tests": [
                "assert string_xor('', '110') == '110', \"XOR with an empty string should return the non-empty string\" (AssertionError: XOR with an empty string should return the non-empty string)",
                "assert string_xor('101', '') == '101', \"XOR with an empty string should return the non-empty string\" (AssertionError: XOR with an empty string should return the non-empty string)"
            ]
        }
    },
    {
        "task_id": "HumanEval/12",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert longest(['', 'a', 'bb']) == 'bb'",
                "assert longest(['ccc', 'bb', 'a']) == 'ccc'",
                "assert longest(['1', '22', '333']) == '333'",
                "assert longest(['only']) == 'only'"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/13",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert greatest_common_divisor(14, 49) == 7",
                "assert greatest_common_divisor(-25, 100) == 25"
            ],
            "failed_tests": [
                "assert greatest_common_divisor(50, -10) == 10 (AssertionError: )",
                "assert greatest_common_divisor(-5, -15) == 5 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/14",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert all_prefixes('a1b2') == ['a', 'a1', 'a1b', 'a1b2']",
                "assert all_prefixes('123') == ['1', '12', '123']",
                "assert all_prefixes('a') == ['a']",
                "assert all_prefixes('a!@') == ['a', 'a!', 'a!@']"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/15",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert string_sequence(0) == \"0\"",
                "assert string_sequence(5) == \"0 1 2 3 4 5\"",
                "assert len(string_sequence(1000000).split(\" \")) == 1000001"
            ],
            "failed_tests": [
                "assert result.startswith(\"0\") and result.endswith(\"2\") and \"  \" not in result (NameError: name 'result' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/16",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert count_distinct_characters('AbCdeFG') == 7",
                "assert count_distinct_characters('aaaaaa') == 1",
                "assert count_distinct_characters('\\naA') == 2",
                "assert count_distinct_characters('a b c') == 4"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/17",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert parse_music('o| o| .| .|') == [2, 2, 1, 1], \"Multiple half and quarter notes\"",
                "assert parse_music('o o| .|') == [4, 2, 1], \"Combination of whole, half, and quarter notes\"",
                "assert parse_music('o    o|     .|') == [4, 2, 1], \"Spaces between notes should not affect the result\"",
                "assert parse_music('.|') == [1], \"Single quarter note should last 1 beat\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/18",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert how_many_times('ababab', 'ab') == 3",
                "assert how_many_times('', 'a') == 0",
                "assert how_many_times('aAaA', 'a') == 2"
            ],
            "failed_tests": [
                "assert how_many_times('abababab', 'abab') == 2 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/19",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert sort_numbers('nine eight seven six five four three two one zero') == 'zero one two three four five six seven eight nine'",
                "assert sort_numbers('one two three') == 'one two three'",
                "assert sort_numbers('six six six') == 'six six six'"
            ],
            "failed_tests": [
                "assert sort_numbers('four five') == 'five four' (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/20",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert find_closest_elements([10000, 20000, 10001]) == (10000, 10001), \"Test with large numbers\"",
                "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2), \"Test with positive numbers where closest elements are distinct\"",
                "assert find_closest_elements([1.0, 2.0, 2.1, 3.0, 3.1]) == (2.0, 2.1), \"Test with list having multiple pairs of closest elements, expecting the first pair found\"",
                "assert find_closest_elements([3.5, 1.2, 2.8, 3.6]) == (3.5, 3.6), \"Test with list having elements in random order\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/21",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]",
                "assert rescale_to_unit([0.0, 1.0, 2.0, 3.0]) == [0.0, 0.3333333333333333, 0.6666666666666666, 1.0]",
                "assert rescale_to_unit([-2.0, -1.0, 0.0, 1.0, 2.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]"
            ],
            "failed_tests": [
                "assert rescale_to_unit([1.0, 1.0, 1.0, 1.0]) == [0.0, 0.0, 0.0, 0.0] (ZeroDivisionError: float division by zero)"
            ]
        }
    },
    {
        "task_id": "HumanEval/22",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert filter_integers([1, None, 2, None]) == [1, 2]",
                "assert filter_integers([10, 20, 30]) == [10, 20, 30]",
                "assert filter_integers([1.0, 2.0, 3.5]) == []",
                "assert filter_integers([1, 2.5, '3', 4]) == [1, 4]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/23",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert strlen('\\n\\n\\n') == 3",
                "assert strlen('HelloWorld') == 10",
                "assert strlen('hello world') == 11",
                "assert strlen('\\t\\t\\t') == 3"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/24",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert largest_divisor(15) == 5",
                "assert True"
            ],
            "failed_tests": [
                "assert False (AssertionError: )",
                "assert False (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/25",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert factorize(8) == [2, 2, 2], \"Should return [2, 2, 2] for 8\"",
                "assert factorize(1001) == [7, 11, 13], \"Should return [7, 11, 13] for 1001\"",
                "assert factorize(1) == [], \"Should return an empty list for 1\"",
                "assert factorize(30) == [2, 3, 5], \"Should return [2, 3, 5] for 30\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/26",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert remove_duplicates([-1, 1, -1, 1, 2, 3, 2]) == [3]",
                "assert remove_duplicates(list(range(-1000, 1001))) == list(range(-1000, 1001))",
                "assert remove_duplicates([-1, -2, -2, -3, -1]) == [-3]",
                "assert remove_duplicates([]) == []"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/27",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert flip_case('Hello\\tWorld') == 'hELLO\\twORLD'",
                "assert flip_case('AAAaaa') == 'aaaAAA'",
                "assert flip_case('Hello, World!') == 'hELLO, wORLD!'",
                "assert flip_case('WORLD') == 'world'"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/28",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert concatenate(['hello ', 'world']) == 'hello world'",
                "assert concatenate(['helloworld']) == 'helloworld'",
                "assert concatenate(['hello', 'world']) == 'helloworld'",
                "assert concatenate(['', 'hello']) == 'hello'"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/29",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']",
                "assert filter_by_prefix([' leadingSpace', 'noLeadingSpace'], ' ') == [' leadingSpace']",
                "assert filter_by_prefix(['1apple', '2banana', '3cherry'], '1') == ['1apple']",
                "assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'z') == []"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/30",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert get_positive([0, 0, 0, 0]) == [], \"Test with zeros only\"",
                "assert get_positive([42]) == [42], \"Test with single positive number\"",
                "assert get_positive([-1, 2, -4, 5, 6, 0]) == [2, 5, 6], \"Test with mixed positive, negative numbers and zero\"",
                "assert get_positive([0]) == [], \"Test with single zero\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/31",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert is_prime(4) == False, \"4 is not a prime number\"",
                "assert is_prime(104729) == True, \"104729 is a prime number\"",
                "assert is_prime(9) == False, \"9 is not a prime number\"",
                "assert is_prime(0) == False, \"0 is not a prime number\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/32",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert round(find_zero([1, 2]), 2) == -0.5, \"Linear polynomial should find correct zero\"",
                "assert poly([2, -3, 0, 1], 3) == 20, \"Cubic polynomial should evaluate correctly\""
            ],
            "failed_tests": [
                "assert round(find_zero([-10, -5, -1]), 2) == -0.2, \"Polynomial with all negative coefficients should find correct zero\" (OverflowError: math range error)",
                "assert round(find_zero([10, 5, 1]), 2) == -2.0, \"Polynomial with all positive coefficients should find correct zero\" (OverflowError: math range error)"
            ]
        }
    },
    {
        "task_id": "HumanEval/33",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert sort_third([3, None, 2, 1]) == [1, None, 2, 3]",
                "assert sort_third([5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5]"
            ],
            "failed_tests": [
                "assert sort_third([1, \"two\", 3.0, \"four\", 5]) == [1, \"two\", 3.0, \"four\", 5] (TypeError: '<' not supported between instances of 'str' and 'int')",
                "assert sort_third([\"banana\", \"apple\", \"cherry\", \"date\"]) == [\"apple\", \"apple\", \"cherry\", \"date\"] (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/34",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert unique([-3, -1, -2, -3, -1]) == [-3, -2, -1]",
                "assert unique([]) == []",
                "assert unique([\"apple\", \"banana\", \"cherry\"]) == [\"apple\", \"banana\", \"cherry\"]",
                "assert unique([1.1, 2.2, 3.3, 2.2, 1.1]) == [1.1, 2.2, 3.3]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/35",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert max_element([-1, -2, -3, -4, -5]) == -1",
                "assert max_element([-999999999999999, 999999999999999]) == 999999999999999",
                "assert max_element([1.000001, 1.000002, 1.000003]) == 1.000003",
                "assert max_element([0, 0, 0, 0]) == 0"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/36",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert fizz_buzz(1) == 0",
                "assert fizz_buzz(-100) == 0"
            ],
            "failed_tests": [
                "assert fizz_buzz(79) == 2 (AssertionError: )",
                "assert fizz_buzz(92) == 1 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/37",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert sort_even([5, -1, 3, -2, -4]) == [-4, -1, 3, -2, 5]",
                "assert sort_even([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2]",
                "assert sort_even([1, 1, 1, 1, 2]) == [1, 1, 1, 1, 2]",
                "assert sort_even([-5, -1, -3, -2, -4]) == [-5, -1, -4, -2, -3]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/38",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert decode_cyclic(\"\") == \"\", \"Decode test with empty string failed\"",
                "assert decode_cyclic(\"ab\") == \"ab\", \"Decode test with string of length 2 failed\"",
                "assert encode_cyclic(\"abc\") == \"bca\", \"Test with string of length 3 failed\"",
                "assert encode_cyclic(\"\") == \"\", \"Test with empty string failed\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/39",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert prime_fib(2) == 3",
                "assert prime_fib(4) == 13",
                "assert prime_fib(1) == 2"
            ],
            "failed_tests": [
                "assert False (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/40",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert triples_sum_to_zero([-5, 2, 3]) == True",
                "assert triples_sum_to_zero([-1, 1, 2, -2, 3, -3]) == True",
                "assert triples_sum_to_zero(list(range(-1000, 1001))) == True",
                "assert triples_sum_to_zero([0, -1, 1, -2, 2, 3, -3, 4]) == True"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/41",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert car_race_collision(1) == 1"
            ],
            "failed_tests": [
                "assert car_race_collision(1000000) == 1000000 (AssertionError: )",
                "assert car_race_collision(10) == 10 (AssertionError: )",
                "assert car_race_collision(1000) == 1000 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/42",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert incr_list(list(range(-3, 4))) == [-2, -1, 0, 1, 2, 3, 4], \"Test with a larger range of numbers failed\"",
                "assert incr_list([1, 2, 3]) == [2, 3, 4], \"Test with a simple list of integers failed\"",
                "assert incr_list([999]) == [1000], \"Test with a large number failed\"",
                "assert incr_list([0]) == [1], \"Test with zero failed\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/43",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert pairs_sum_to_zero([1, 2]) == False",
                "assert pairs_sum_to_zero([]) == False",
                "assert pairs_sum_to_zero([1, 2, 3, 4]) == False",
                "assert pairs_sum_to_zero([0, 1, 2, 3]) == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/44",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert change_base(9, 3) == '100'",
                "assert change_base(8, 3) == '22'",
                "assert change_base(2, 2) == '10'",
                "assert change_base(9, 9) == '10'"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/45",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert triangle_area(0, 10) == 0",
                "assert triangle_area(5, 3) == 7.5",
                "assert triangle_area(10000, 3000) == 15000000.0"
            ],
            "failed_tests": [
                "assert triangle_area(-5, -3) == \"Error\" or similar (NameError: name 'similar' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/46",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert isinstance(fib4(100), int), \"fib4(100) should return an integer without timing out\"",
                "assert fib4(3) == 0, \"Base case fib4(3) should return 0\"",
                "assert fib4(0) == 0, \"Base case fib4(0) should return 0\""
            ],
            "failed_tests": [
                "assert fib4(10) == 88, \"fib4(10) should return 88\" (AssertionError: fib4(10) should return 88)"
            ]
        }
    },
    {
        "task_id": "HumanEval/47",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert median([1, 2, 3, 4, 5]) == 3",
                "assert median([-5, -10, -1, -3]) == -4.0",
                "assert median([100, 200]) == 150.0"
            ],
            "failed_tests": [
                "assert median([-10, 4, 6, 1000, 10, 20]) == 15.0 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/48",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert is_palindrome('') == True",
                "assert is_palindrome('a') == True",
                "assert is_palindrome('racecar') == True",
                "assert is_palindrome('1a2b3c4d') == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/49",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert modp(1101, 101) == 2",
                "assert modp(10, 1) == 0",
                "assert modp(0, 101) == 1"
            ],
            "failed_tests": [
                "assert modp(3, -5) == SOME_DEFINED_VALUE_OR_ERROR (NameError: name 'SOME_DEFINED_VALUE_OR_ERROR' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/50",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert encode_shift(\"\") == \"\", \"Should return an empty string for empty input\"",
                "assert encode_shift(\"xyz\") == \"cde\", \"Should wrap around and encode 'xyz' to 'cde'\""
            ],
            "failed_tests": [
                "assert encode_shift(\"hello world\") == \"mjqqt btwqi\", \"Should encode 'hello world' to 'mjqqt btwqi'\" (AssertionError: Should encode 'hello world' to 'mjqqt btwqi')",
                "assert decode_shift(\"mjqqt btwqi\") == \"hello world\", \"Should decode 'mjqqt btwqi' back to 'hello world'\" (AssertionError: Should decode 'mjqqt btwqi' back to 'hello world')"
            ]
        }
    },
    {
        "task_id": "HumanEval/51",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert remove_vowels('aaeeiioouu') == '', \"Should remove all instances of each vowel\"",
                "assert remove_vowels('123abc') == '123bc', \"Should ignore numbers and remove vowels\"",
                "assert remove_vowels('bcdfgh') == 'bcdfgh', \"Should return the same string when it contains only consonants\""
            ],
            "failed_tests": [
                "assert remove_vowels('AbCdEfG') == 'bCdFG', \"Should remove vowels and maintain case of consonants\" (AssertionError: Should remove vowels and maintain case of consonants)"
            ]
        }
    },
    {
        "task_id": "HumanEval/52",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert below_threshold([0, 1, 2, 3], 4) == True",
                "assert below_threshold([], 5) == True",
                "assert below_threshold([-999999999, 1, 2, 3, 999999998], 999999999) == True",
                "assert below_threshold([0, 1, 2, 3], 0) == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/53",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert add(0, 0) == 0",
                "assert add(-3, 2) == -1",
                "assert add(-2, -3) == -5",
                "assert add(-2, 3) == 1"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/54",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert same_chars('aAb', 'baA') == True, \"Should return True for strings with uppercase and lowercase of the same character\"",
                "assert same_chars('123', '321') == True, \"Should return True for strings with same numeric characters in different order\"",
                "assert same_chars('a'*1000 + 'b'*1000, 'b'*1000 + 'a'*1000) == True, \"Should return True for long strings with same characters in different quantities\"",
                "assert same_chars('abc', 'xyz') == False, \"Should return False for strings with no common characters\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/55",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert fib(1) == 1",
                "assert fib(2) == 1",
                "assert fib(8) == 21"
            ],
            "failed_tests": [
                "assert False, f\"Expected a ValueError, but got {type(e)}\" (NameError: name 'e' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/56",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert correct_bracketing(\"<>\") == True",
                "assert correct_bracketing(\"><\") == False",
                "assert correct_bracketing(\"><<>\") == False",
                "assert correct_bracketing(\"<\") == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/57",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert monotonic([3, 2, 1, 2, 3]) == False",
                "assert monotonic([-10, -5, 0, 5]) == True",
                "assert monotonic([1, 2, 3, 2, 1]) == False",
                "assert monotonic([1, 1, 2, 3]) == True"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/58",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert common([5, 3, 2, 8], [3, 2]) == [2, 3]",
                "assert common([1, \"a\", 2.2], [\"b\", 3.3]) == []",
                "assert common([], []) == []",
                "assert common([True, False, True], [False, True]) == [False, True]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/59",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert largest_prime_factor(2048) == 2",
                "assert largest_prime_factor(49) == 7"
            ],
            "failed_tests": [
                "assert largest_prime_factor(13860) == 23 (AssertionError: )",
                "assert largest_prime_factor(600851475143) == 6857 (TimeoutError: Test case execution exceeded 10 seconds)"
            ]
        }
    },
    {
        "task_id": "HumanEval/60",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert sum_to_n(100) == 5050",
                "assert sum_to_n(1) == 1",
                "assert sum_to_n(10) == 55",
                "assert sum_to_n(0) == 0"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/61",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert correct_bracketing(\")(()\") == False",
                "assert correct_bracketing(\"(()(())())\") == True",
                "assert correct_bracketing(\"(\") == False",
                "assert correct_bracketing(\"((())())(()\") == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/62",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert derivative([5]) == []",
                "assert derivative([]) == []",
                "assert derivative([1, 3, 2]) == [3, 4]",
                "assert derivative([-1, -2, -3]) == [-2, -6]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/63",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert True, \"Expected an error or handling for negative input\"",
                "assert fibfib(8) == 24, \"fibfib(8) should be 24\""
            ],
            "failed_tests": [
                "assert fibfib(4) == 4, \"fibfib(4) should be 4 (2+1+1)\" (AssertionError: fibfib(4) should be 4 (2+1+1))",
                "assert fibfib(3) == 2, \"fibfib(3) should be 2 (1+0+1)\" (AssertionError: fibfib(3) should be 2 (1+0+1))"
            ]
        }
    },
    {
        "task_id": "HumanEval/64",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert vowels_count(\"aeiou\") == 5",
                "assert vowels_count(\"banana\") == 3"
            ],
            "failed_tests": [
                "assert vowels_count(\"happy\") == 1 (AssertionError: )",
                "assert vowels_count(\"Hello, world! My name is Python.\") == 8 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/65",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert circular_shift(1234, 5) == \"4321\", \"Should return the digits reversed when shift is more than the number of digits\"",
                "assert circular_shift(7, 1) == \"7\", \"Single digit numbers should return the same number regardless of the shift\"",
                "assert circular_shift(1234, 1) == \"4123\", \"Should shift digits to the right by 1\""
            ],
            "failed_tests": [
                "assert circular_shift(-123, 2) == \"12-3\", \"Should handle negative numbers by shifting digits to the right\" (AssertionError: Should handle negative numbers by shifting digits to the right)"
            ]
        }
    },
    {
        "task_id": "HumanEval/66",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert digitSum(\"A\" * 1000) == 65000",
                "assert digitSum(\"abcCd\") == 67",
                "assert digitSum(\"abAB\") == 131"
            ],
            "failed_tests": [
                "assert digitSum(\"\u00dcml\u00e4utA\") == 65 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/67",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert fruit_distribution(\"5 apples and 5 oranges\", 15) == 5, \"Test with 5 apples, 5 oranges, and total 15 fruits\"",
                "assert fruit_distribution(\"5 apples and 5 oranges\", 10) == 0, \"Test with 5 apples, 5 oranges, and total 10 fruits\"",
                "assert fruit_distribution(\"10 apples and 10 oranges\", 30) == 10, \"Test with 10 apples, 10 oranges, and total 30 fruits\"",
                "assert fruit_distribution(\"10 apples and 10 oranges\", 20) == 0, \"Test with 10 apples, 10 oranges, and total 20 fruits\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/68",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert pluck([3]) == []",
                "assert pluck([4]) == [4, 0]",
                "assert pluck([i for i in range(10000)]) == [0, 0]",
                "assert pluck([3, 5, 7, 10]) == [10, 3]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/69",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert search([2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3]) == 3",
                "assert search([10, 10, 20, 20, 30]) == -1",
                "assert search([1]) == 1",
                "assert search([5, 5, 4, 4, 4]) == -1"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/70",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5], \"Test with identical integers list failed\"",
                "assert strange_sort_list([2, 2, 2, 3, 3, 3]) == [2, 3, 2, 3, 2, 3], \"Test where max and min are the same failed\"",
                "assert strange_sort_list([2, 3, 2, 3]) == [2, 3, 2, 3], \"Test with duplicates in list failed\"",
                "assert strange_sort_list([-1, 2, -3, 4]) == [-3, 4, -1, 2], \"Test with mixed integers list failed\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/71",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert triangle_area(5, 5, 5) == round(10.825317547305483, 2)",
                "assert triangle_area(5, 5, 8) == round(12.0, 2)"
            ],
            "failed_tests": [
                "assert triangle_area(10000, 10000, 10000) == round(43301.27018922193, 2) (AssertionError: )",
                "assert triangle_area(1, 1, 1.999) == round(0.968, 2) (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/72",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert will_it_fly([1, 2], 5) == False",
                "assert will_it_fly([-1, 2, -1], 1) == True",
                "assert will_it_fly([2, 2, 2, 2], 9) == True",
                "assert will_it_fly([3], 5) == True"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/73",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert smallest_change([-1, -2, -3, -2, -1]) == 0",
                "assert smallest_change([1, 2]) == 1",
                "assert smallest_change([-1, -2, -3, -4, -5, -6, -7]) == 3",
                "assert smallest_change([2, 2]) == 0"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/74",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert total_match(['hello', 'world'], ['hi', 'there']) == ['hi', 'there'], \"Second list has fewer total characters.\"",
                "assert total_match(['short', 'longer', 'longest'], ['tiny', 'medium', 'sizeable']) == ['short', 'longer', 'longest'], \"First list has fewer total characters despite varying lengths.\"",
                "assert total_match([], ['not', 'empty']) == [], \"One list empty and the other not, should return the empty list.\""
            ],
            "failed_tests": [
                "assert total_match(['123', '456'], ['78910']) == ['123', '456'], \"List with numeric strings, first list has fewer total characters.\" (AssertionError: List with numeric strings, first list has fewer total characters.)"
            ]
        }
    },
    {
        "task_id": "HumanEval/75",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert is_multiply_prime(210) == False"
            ],
            "failed_tests": [
                "assert is_multiply_prime(50) == False (AssertionError: )",
                "assert is_multiply_prime(27) == False (AssertionError: )",
                "assert is_multiply_prime(99) == False (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/76",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert is_simple_power(1, 4) == True, \"1 is a simple power of any number\"",
                "assert is_simple_power(3, 1) == False, \"Any number to the power of 1 is the number itself, not a simple power\"",
                "assert is_simple_power(0.5, 2) == False, \"Fractional results are not considered simple powers\"",
                "assert is_simple_power(8, -2) == False, \"Negative exponent should return False as it results in a fraction\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/77",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert iscube(0) == True, \"0 is 0^3\"",
                "assert iscube(729) == True, \"729 is 9^3\"",
                "assert iscube(1) == True, \"1 is 1^3\"",
                "assert iscube(-8) == True, \"-8 is -2^3\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/78",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert hex_key(\"777\") == 3, \"Test with repeated prime hexadecimal digits '777'\"",
                "assert hex_key(\"468A0\") == 0, \"Test with no prime hexadecimal digits '468A0'\"",
                "assert hex_key(\"237B\") == 4, \"Test with multiple prime hexadecimal digits '237B'\"",
                "assert hex_key(\"\") == 0, \"Test with an empty string\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/79",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert decimal_to_binary(32) == \"db100000db\"",
                "assert decimal_to_binary(21) == \"db10101db\"",
                "assert decimal_to_binary(0) == \"db0db\""
            ],
            "failed_tests": [
                "assert decimal_to_binary(2048) == \"db10000000000db\" (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/80",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert is_happy('abcdaaefg') == False",
                "assert is_happy('aaa') == False",
                "assert is_happy('abcdef') == True"
            ],
            "failed_tests": [
                "assert is_happy('abcdc') == True (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/81",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert numerical_letter_grade([0.0]) == ['E']",
                "assert numerical_letter_grade([0.1]) == ['D-']",
                "assert numerical_letter_grade([3.75, 2.75, 1.75, 0.75]) == ['A', 'B', 'C', 'D']"
            ],
            "failed_tests": [
                "assert numerical_letter_grade([3.0, 3.0, 3.0]) == ['B+', 'B+', 'B+'] (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/82",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert prime_length('orange') == False",
                "assert prime_length('kittens') == True",
                "assert prime_length('Hello') == True",
                "assert prime_length('A') == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/83",
        "is_solved": false,
        "test_results": {
            "passed_tests": [],
            "failed_tests": [
                "assert starts_one_ends(2) == 11 (AssertionError: )",
                "assert starts_one_ends(10) == 20 * (9 ** 8) * 10 + (10 ** 9) (AssertionError: )",
                "assert starts_one_ends(-1) == \"Error\" (AssertionError: )",
                "assert starts_one_ends(0) == \"Error\" (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/84",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert solve(10000) == \"1\"",
                "assert solve(1) == \"1\""
            ],
            "failed_tests": [
                "assert solve(9999) == \"111100\" (AssertionError: )",
                "assert solve(99) == \"11000\" (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/85",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert add([1, 3, 5, 7, 9]) == 0",
                "assert add(list(range(1, 10001))) == sum(x for x in range(1, 10001) if x % 2 == 0 and (list(range(1, 10001)).index(x) % 2 != 0))",
                "assert add([2]) == 0"
            ],
            "failed_tests": [
                "assert add([-1, -2, -3, -4, -5, -6]) == -8 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/86",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert anti_shuffle('Hi') == 'Hi', \"Test with input 'Hi' should return 'Hi'\"",
                "assert anti_shuffle('a') == 'a', \"Test with input 'a' should return 'a'\"",
                "assert anti_shuffle('\u00e9\u00e0\u00e8') == '\u00e0\u00e8\u00e9', \"Test with input '\u00e9\u00e0\u00e8' should return '\u00e0\u00e8\u00e9'\"",
                "assert anti_shuffle('abc123') == '123abc', \"Test with input 'abc123' should return '123abc'\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/87",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert get_row([\n  [2,3],\n  [4,5],\n  [6,7,1]\n], 1) == [(2, 2)]",
                "assert get_row([\n  list(range(1, 101)),\n  list(range(101, 201)),\n  list(range(201, 301))\n], 150) == [(1, 49)]",
                "assert get_row([\n  [1, -1, 2],\n  [3, -3, -1],\n  [-1, 4, 5]\n], -1) == [(0, 1), (1, 2), (2, 0)]",
                "assert get_row([], 1) == []"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/88",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert sort_array([0, 0, 0, 0]) == [0, 0, 0, 0], \"Test with an array of zeros should return the same array.\""
            ],
            "failed_tests": [
                "assert sort_array([2, 4, 3, 0, 1, 5, 6]) == [0, 1, 2, 3, 4, 5, 6], \"Test with an odd sum of first and last elements should return array in ascending order.\" (AssertionError: Test with an odd sum of first and last elements should return array in ascending order.)",
                "assert sort_array([2, 4, 3, 0, 1, 5]) == [5, 4, 3, 2, 1, 0], \"Test with an even sum of first and last elements should return array in descending order.\" (AssertionError: Test with an even sum of first and last elements should return array in descending order.)",
                "assert sorted_array != original_array, \"The sorted array should be a new array, not a modification of the original.\" (NameError: name 'sorted_array' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/89",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert encrypt('gf') == 'kj', \"Pair 'gf' should return 'kj'\"",
                "assert encrypt('h1i') == 'l1m', \"'h1i' should return 'l1m' with the number unchanged\""
            ],
            "failed_tests": [
                "assert encrypt('AbCd') == 'CdEf', \"Mixed case 'AbCd' should return 'CdEf'\" (AssertionError: Mixed case 'AbCd' should return 'CdEf')",
                "assert encrypt('AB') == 'CD', \"Uppercase 'AB' should return 'CD'\" (AssertionError: Uppercase 'AB' should return 'CD')"
            ]
        }
    },
    {
        "task_id": "HumanEval/90",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert next_smallest([10, -1, 0, 1, 2]) == 0",
                "assert next_smallest([1, 2, 3, 4, 5]) == 2",
                "assert next_smallest([1]) == None",
                "assert next_smallest([5, 4, 3, 2, 1]) == 2"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/91",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert is_bored(\"I am feeling bored.\") == 1",
                "assert is_bored(\"\") == 0",
                "assert is_bored(\"The sky is blue. I love sunny days. What about you?\") == 1"
            ],
            "failed_tests": [
                "assert is_bored(\"I am feeling bored I don't know what to do\") == 0 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/92",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert any_int(1000000, 500000, 500000) == True, \"Should return True with large integers when one number is the sum of the other two\"",
                "assert any_int(1000000, 1, 2) == False, \"Should return False when one number is much larger than the sum of the other two\"",
                "assert any_int(0, -5, 5) == True, \"Should return True when zero is one of the numbers and makes the sum possible\"",
                "assert any_int(3, -2, 1) == True, \"Should return True with negative numbers when one number is the sum of the other two\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/93",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert encode('test') == 'TGST', \"Should encode 'test' to 'TGST'\"",
                "assert encode('This is a message') == 'tHKS KS C MGSSCGG', \"Should encode 'This is a message' to 'tHKS KS C MGSSCGG'\"",
                "assert encode('bcdfg') == 'BCDFG', \"Should encode 'bcdfg' to 'BCDFG'\""
            ],
            "failed_tests": [
                "assert encode('AEIOU') == 'cgkqm', \"Should encode 'AEIOU' to 'cgkqm'\" (AssertionError: Should encode 'AEIOU' to 'cgkqm')"
            ]
        }
    },
    {
        "task_id": "HumanEval/94",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert skjkasdkd([7, 7, 7, 7]) == 7, \"Test with repeated prime numbers\"",
                "assert skjkasdkd([181, 3, 7, 11]) == 10, \"Test with multiple primes, largest at the beginning\"",
                "assert skjkasdkd([4, 6, 8, 10]) == 0, \"Test with no prime numbers\""
            ],
            "failed_tests": [
                "assert skjkasdkd([2, 3, 5, 7, 99991]) == 28, \"Test with a large prime number\" (AssertionError: Test with a large prime number)"
            ]
        }
    },
    {
        "task_id": "HumanEval/95",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert check_dict_case({}) == False, \"Empty dictionary should return False\"",
                "assert check_dict_case({\"ONE\":1, \"TWO\":2}) == True, \"Numeric values but upper case string keys should return True\"",
                "assert check_dict_case({\"ONE\":1, \"TWO\":\"two\"}) == True, \"Mixed values but all upper case keys should return True\"",
                "assert check_dict_case({\"SINGLE\":\"value\"}) == True, \"Single upper case key should return True\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/96",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert count_up_to(5) == [2, 3]",
                "assert count_up_to(18) == [2, 3, 5, 7, 11, 13, 17]",
                "assert count_up_to(20) == [2, 3, 5, 7, 11, 13, 17, 19]",
                "assert count_up_to(1) == []"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/97",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert multiply(-23, -47) == 21, \"Should be 21\"",
                "assert multiply(123456789, 987654321) == 9, \"Should be 9\"",
                "assert multiply(9, 123) == 27, \"Should be 27\"",
                "assert multiply(6, 123456789) == 54, \"Should be 54\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/98",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert count_upper('B') == 0, \"Should return 0 as the single character is an uppercase consonant\"",
                "assert count_upper('aBCdEf') == 1, \"Should count 1 uppercase vowel at an even index\"",
                "assert count_upper('a') == 0, \"Should return 0 as the single character is a lowercase vowel\""
            ],
            "failed_tests": [
                "assert count_upper('1A!E@3R') == 1, \"Should count 1 uppercase vowel at an even index, ignoring special characters and numbers\" (AssertionError: Should count 1 uppercase vowel at an even index, ignoring special characters and numbers)"
            ]
        }
    },
    {
        "task_id": "HumanEval/99",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert closest_integer(\"99.9999\") == 100",
                "assert closest_integer(\"10\") == 10",
                "assert closest_integer(\"-10\") == -10",
                "assert closest_integer(\"-14.5\") == -15"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/100",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert make_a_pile(7) != [], \"The function should not return an empty list for positive n\"",
                "assert make_a_pile(1) == [1], \"Test with n=1 should return [1]\""
            ],
            "failed_tests": [
                "assert even_result == [4, 6, 8, 10], \"For n=4, the sequence should increase by 2 starting from 4\" (NameError: name 'even_result' is not defined)",
                "assert odd_result == [3, 5, 7], \"For n=3, the sequence should increase by 2 starting from 3\" (NameError: name 'odd_result' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/101",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert words_string(\"Solo\") == [\"Solo\"]",
                "assert words_string(\"Multiple   spaces    here\") == [\"Multiple\", \"spaces\", \"here\"]",
                "assert words_string(\"One,two,three,four,five,six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]",
                "assert words_string(\"Mix, of,  spaces,and,,,commas\") == [\"Mix\", \"of\", \"spaces\", \"and\", \"commas\"]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/102",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert choose_num(-4, -1) == -2",
                "assert choose_num(8, 15) == 14",
                "assert choose_num(1, 100) == 100",
                "assert choose_num(-2, 3) == 2"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/103",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert rounded_avg(7, 7) == bin(7), \"Test case where n equals m\"",
                "assert rounded_avg(1000, 2000) == bin((1000 + 2000) // 2), \"Test case with very large range\"",
                "assert rounded_avg(100, 100) == bin(100), \"Test case with a single large number\""
            ],
            "failed_tests": [
                "assert rounded_avg(4, 5) == \"0b101\", \"Test case with consecutive numbers\" (AssertionError: Test case with consecutive numbers)"
            ]
        }
    },
    {
        "task_id": "HumanEval/104",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert unique_digits([15, 33, 1422, 1, 999999999999]) == [1, 15, 33, 999999999999]",
                "assert unique_digits([152, 323, 1422, 10]) == []",
                "assert unique_digits([15, 33, 1422, 1, 123456789012345678901234567890]) == [1, 15, 33]"
            ],
            "failed_tests": [
                "assert unique_digits([15, -33, 1422, 1, -5]) == [1, 15] (ValueError: invalid literal for int() with base 10: '-')"
            ]
        }
    },
    {
        "task_id": "HumanEval/105",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert by_length([-1, -2, 3, 4, -5, 6]) == [\"Six\", \"Four\", \"Three\"]",
                "assert by_length([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [\"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]",
                "assert by_length([5]) == [\"Five\"]",
                "assert by_length([9, 9, 9]) == [\"Nine\", \"Nine\", \"Nine\"]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/106",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert f(1) == [1]",
                "assert f(6) == [1, 2, 6, 24, 15, 720]",
                "assert f(0) == []",
                "assert f(3) == [1, 2, 6]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/107",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert even_odd_palindrome(1) == (0, 1), \"Test with n=1, expecting 0 even and 1 odd palindrome\"",
                "assert even_odd_palindrome(13) == (4, 6), \"Test with prime n=13, expecting 4 even and 6 odd palindromes\"",
                "assert even_odd_palindrome(11) == (4, 6), \"Test with n=11, including itself as an odd palindrome\""
            ],
            "failed_tests": [
                "assert even_odd_palindrome(22) == (9, 12), \"Test with n=22, just after adding a new two-digit palindrome\" (AssertionError: Test with n=22, just after adding a new two-digit palindrome)"
            ]
        }
    },
    {
        "task_id": "HumanEval/108",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert count_nums([5]) == 1",
                "assert count_nums([-12]) == 1",
                "assert count_nums([-10, 23, -45, 6]) == 3"
            ],
            "failed_tests": [
                "assert count_nums([-111]) == 0 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/109",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert move_one_ball([5, 1, 2, 3, 4]) == True, \"Should return True for an array that needs one right shift\"",
                "assert move_one_ball(list(range(2, 10001)) + [1]) == True, \"Should return True for a large array that needs n-1 right shifts\"",
                "assert move_one_ball([2, 1, 3, 5, 4]) == False, \"Should return False for an array that cannot be sorted with right shifts\"",
                "assert move_one_ball([4, 5, 1, 2, 3]) == True, \"Should return True for an array that needs multiple right shifts\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/110",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert exchange([2, 4, 6], []) == \"YES\"",
                "assert exchange([2, 4, 6], [1, 3, 5]) == \"YES\"",
                "assert exchange([1, 3, 5], [1, 3, 5]) == \"NO\"",
                "assert exchange([0, 2, 4], [1, 3, 5]) == \"YES\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/111",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert histogram('a') == {'a': 1}, \"Test with a single letter failed.\"",
                "assert histogram('a b c d e f') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1}, \"Test with all letters being unique failed.\"",
                "assert histogram('b b b b a') == {'b': 4}, \"Test with only one letter repeated multiple times failed.\"",
                "assert histogram('a a b') == {'a': 2}, \"Test with two letters being repeated different number of times failed.\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/112",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert reverse_delete(\"abcdefg\", \"a\") == (\"bcdefg\", False)",
                "assert reverse_delete(\"abccba\", \"a\") == (\"bccb\", True)",
                "assert reverse_delete(\"AaBbCc\", \"a\") == (\"ABbCc\", False)"
            ],
            "failed_tests": [
                "assert reverse_delete(\"abcdefghihgfedcba\", \"aeb\") == (\"cdfghihgfcdc\", False) (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/113",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert odd_count(['2468']) == [\"the number of odd elements 0n the str0ng 0 of the 0nput.\"]",
                "assert odd_count(['13579']) == [\"the number of odd elements 5n the str5ng 5 of the 5nput.\"]",
                "assert odd_count([]) == []",
                "assert odd_count(['2468', '42', '86420']) == [\n\"the number of odd elements 0n the str0ng 0 of the 0nput.\",\n\"the number of odd elements 0n the str0ng 0 of the 0nput.\",\n\"the number of odd elements 0n the str0ng 0 of the 0nput.\"\n]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/114",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert minSubArraySum([1, -2, 3, -4, 5]) == -4",
                "assert minSubArraySum([0, 0, 0, 0]) == 0",
                "assert minSubArraySum([5]) == 5"
            ],
            "failed_tests": [
                "assert minSubArraySum([]) == 0 (ValueError: max() arg is an empty sequence)"
            ]
        }
    },
    {
        "task_id": "HumanEval/115",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Test case 1 failed\"",
                "assert max_fill([[1,0,1], [0,1,1,1], [1,1]], 4) == 3, \"Test case 8 failed\"",
                "assert max_fill([[0,0,0], [0,0,0]], 5) == 0, \"Test case 3 failed\"",
                "assert max_fill([[1]*10 for _ in range(10)], 1) == 100, \"Test case 12 failed\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/116",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert sort_array([]) == []",
                "assert sort_array([7, 3, 5]) == [3, 5, 7]"
            ],
            "failed_tests": [
                "assert sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] (AssertionError: )",
                "assert sort_array(list(range(1000, 0, -1))) == sorted(list(range(1000, 0, -1))) (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/117",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert select_words(\"Uncle sam\", 3) == [\"Uncle\"], \"Test with a single word having exactly 3 consonants, case sensitivity\"",
                "assert select_words(\"Mary had a little lamb\", 4) == [\"little\"], \"Test with words having exactly 4 consonants\"",
                "assert select_words(\"This is quite a challenge\", 100) == [], \"Test with an unrealistically high number of consonants\"",
                "assert select_words(\"simple white space\", 2) == [], \"Test with no words having exactly 2 consonants\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/118",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert get_closest_vowel(\"obstacle\") == \"a\", \"Should return 'a' as it is the closest vowel between two consonants from the right ignoring beginning and ending vowels\"",
                "assert get_closest_vowel(\"FULL\") == \"U\", \"Should return 'U' as it is the closest vowel between two consonants from the right in uppercase\"",
                "assert get_closest_vowel(\"quick\") == \"\", \"Should return an empty string as there's no vowel between two consonants\""
            ],
            "failed_tests": [
                "assert get_closest_vowel(\"articulate\") == \"u\", \"Should return 'u' as it is the closest vowel between two consonants from the right ignoring starting and ending vowels\" (AssertionError: Should return 'u' as it is the closest vowel between two consonants from the right ignoring starting and ending vowels)"
            ]
        }
    },
    {
        "task_id": "HumanEval/119",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert match_parens(['(()(()', '())())']) == 'Yes', \"Complex case that results in a good string\"",
                "assert match_parens(['()(', ')']) == 'Yes', \"Concatenating '()(' and ')' should result in 'Yes'\"",
                "assert match_parens([')(', '()']) == 'No', \"Neither order produces a good string, should result in 'No'\"",
                "assert match_parens([')(', ')(']) == 'No', \"Two bad strings should result in 'No'\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/120",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert maximum([-1, 3, 2, -4], 3) == [-1, 2, 3]",
                "assert maximum([3, 1, 2], 3) == [1, 2, 3]",
                "assert maximum([1, 2, 2, 3], 2) == [2, 3]",
                "assert maximum(list(range(-500, 500)), 1) == [499]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/121",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert solution([2, 4, 6, 8, 10]) == 0"
            ],
            "failed_tests": [
                "assert solution([0, 1, 0, 3, 0, 5, 0]) == 4 (AssertionError: )",
                "assert solution([5]) == 0 (AssertionError: )",
                "assert solution([-2, -3, -4, -5, -6, -7]) == -8 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/122",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert add_elements([100, 200, 3, 40], 4) == 43, \"Test with numbers having more than two digits\"",
                "assert add_elements([100, 200, 300, 400], 4) == 0, \"Test with all elements having more than two digits\""
            ],
            "failed_tests": [
                "assert add_elements([-10, 20, -30, 40], 4) == 20, \"Test with mixed positive and negative numbers\" (AssertionError: Test with mixed positive and negative numbers)",
                "assert add_elements([-10, -20, 30, -40], 4) == -40, \"Test with negative numbers\" (AssertionError: Test with negative numbers)"
            ]
        }
    },
    {
        "task_id": "HumanEval/123",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert get_odd_collatz(1) == [1], \"Test with n=1, expecting [1]\""
            ],
            "failed_tests": [
                "assert get_odd_collatz(13) == [1, 5, 10, 13, 20, 40], \"Test with n=13, a prime number, expecting sorted odd numbers in its Collatz sequence\" (AssertionError: Test with n=13, a prime number, expecting sorted odd numbers in its Collatz sequence)",
                "assert get_odd_collatz(2147483647) == [...], \"Test with the maximum 32-bit integer, expecting sorted odd numbers in its Collatz sequence\" (AssertionError: Test with the maximum 32-bit integer, expecting sorted odd numbers in its Collatz sequence)",
                "assert get_odd_collatz(27) == [1, 5, 7, 10, 13, 17, 20, 27, 40, 41, 53, 54, 55, 68, 82, 83], \"Test with n=27, expecting sorted odd numbers in its long Collatz sequence\" (AssertionError: Test with n=27, expecting sorted odd numbers in its long Collatz sequence)"
            ]
        }
    },
    {
        "task_id": "HumanEval/124",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert valid_date('13-15-2020') == False, \"Month greater than 12 should return False\"",
                "assert valid_date('03-11-2000') == True, \"Valid date in correct format should return True\"",
                "assert valid_date('01-03-2023') == True, \"Valid date with leading zeros in month and day should return True\"",
                "assert valid_date('02-29-2020') == True, \"29th February in a leap year should return True\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/125",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert split_words(\"Hello world!\") == [\"Hello\", \"world!\"]"
            ],
            "failed_tests": [
                "assert split_words(\"    \") == [\"\", \"\", \"\", \"\", \"\"] (AssertionError: )",
                "assert split_words(\",,,,\") == [\"\", \"\", \"\", \"\", \"\"] (AssertionError: )",
                "assert split_words(\"bdfhjlnprtvxz\") == 0 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/126",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert is_sorted([1, 3, 2, 4, 5, 6, 7]) == False, \"Long unsorted list should return False\"",
                "assert is_sorted([1, 3, 2, 4, 5]) == False, \"Unsorted list should return False\"",
                "assert is_sorted([1, 2, 3, 4, 5]) == True, \"Sorted list should return True\"",
                "assert is_sorted([1, 2, 2, 2, 3, 4]) == False, \"List with more than one duplicate should return False\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/127",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert intersection((1, 2), (3, 4)) == \"NO\", \"Test when intervals do not intersect\"",
                "assert intersection((100, 200), (199, 300)) == \"NO\", \"Test with large intervals that have a non-prime length intersection\"",
                "assert intersection((1, 2), (2, 3)) == \"NO\", \"Test when intervals intersect at a single point\""
            ],
            "failed_tests": [
                "assert intersection((1, 10), (2, 3)) == \"YES\", \"Test when one interval is completely within the other with a prime length\" (AssertionError: Test when one interval is completely within the other with a prime length)"
            ]
        }
    },
    {
        "task_id": "HumanEval/128",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert prod_signs([0, 1, -2, 3]) == 0, \"Should return 0 if any number is 0\"",
                "assert prod_signs([1, -2, 3]) == -6, \"Should return negative sum for odd count of negative numbers\"",
                "assert prod_signs([5]) == 5, \"Should return the number itself if array contains only one positive number\"",
                "assert prod_signs([0]) == 0, \"Should return 0 if array contains only one number and it's 0\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/129",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert minPath([[1,2,3], [4,5,6], [7,8,9]], 3) == [1, 2, 1], \"Test case 3 failed\""
            ],
            "failed_tests": [
                "assert minPath([[1]], 1) == [1], \"Test case 6 failed\" (ValueError: min() arg is an empty sequence)",
                "assert minPath([[15,14,13], [12,11,10], [9,8,7]], 3) == [7, 8, 7], \"Test case 9 failed\" (AssertionError: Test case 9 failed)",
                "assert minPath([[1,2,3], [4,5,6], [7,8,9]], 9) == [1,2,1,2,3,2,1,2,3], \"Test case 2 failed\" (AssertionError: Test case 2 failed)"
            ]
        }
    },
    {
        "task_id": "HumanEval/130",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert tri(1) == [1, 3], \"Test with n=1 should return [1, 3]\"",
                "assert tri(2) == [1, 3, 2], \"Test with n=2 should return [1, 3, 2]\"",
                "assert tri(0) == [1], \"Test with n=0 should return [1]\"",
                "assert tri(4) == [1, 3, 2, 8, 3], \"Test with n=4 should return [1, 3, 2, 8, 3]\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/131",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert digits(1024) == 1",
                "assert digits(123456789) == 945",
                "assert digits(1) == 1",
                "assert digits(224466) == 0"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/132",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert is_nested('[]') == False, \"Test with a single pair of brackets failed\"",
                "assert is_nested('[[]][[') == True, \"Test with a nested structure that ends open failed\"",
                "assert is_nested('[[[[[]]]]]') == True, \"Test with a deeply nested structure failed\""
            ],
            "failed_tests": [
                "assert is_nested('[]' * 5) == False, \"Test with alternating open and close brackets failed\" (AssertionError: Test with alternating open and close brackets failed)"
            ]
        }
    },
    {
        "task_id": "HumanEval/133",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert sum_squares([0.1, 0.01, 0.001]) == 3, \"Test with very small floating point numbers failed\"",
                "assert sum_squares([1, 4, 9]) == 98, \"Test with perfect squares failed\"",
                "assert sum_squares([-2.4, 1, 1]) == 6, \"Test with negative and positive numbers failed\"",
                "assert sum_squares([0, 2, 4.5]) == 29, \"Test with zero and positive numbers failed\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/134",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert check_if_last_char_is_a_letter(\"hello world e\") == True",
                "assert check_if_last_char_is_a_letter(\"   \") == False",
                "assert check_if_last_char_is_a_letter(\"\") == False",
                "assert check_if_last_char_is_a_letter(\"hello world  \") == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/135",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert can_arrange([-2, -1, 0, 1, 2, 1]) == 5",
                "assert can_arrange([2, 3, 4, 1]) == 3",
                "assert can_arrange([-3, -1, 2, 4, 6]) == -1",
                "assert can_arrange([1, 2, 4, 3, 5]) == 3"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/136",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert largest_smallest_integers([-2, -4, -1, -3, -5, -7]) == (-1, None)",
                "assert largest_smallest_integers([-1000000, 1000000, -1, 1]) == (-1, 1)",
                "assert largest_smallest_integers([0]) == (None, None)",
                "assert largest_smallest_integers([5]) == (None, 5)"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/137",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert compare_one(\"2,5\", 2) == \"2,5\"",
                "assert compare_one(1000000000000, \"1000000000001\") == \"1000000000001\"",
                "assert compare_one(-1000000000000, \"-999999999999\") == \"-999999999999\"",
                "assert compare_one(1.1, 2.2) == 2.2"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/138",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert is_equal_to_sum_even(2) == False",
                "assert is_equal_to_sum_even(8) == True",
                "assert is_equal_to_sum_even(100) == True",
                "assert is_equal_to_sum_even(6) == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/139",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert True",
                "assert special_factorial(4) == 288",
                "assert True"
            ],
            "failed_tests": [
                "assert False (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/140",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert fix_spaces(\"   Example 4\") == \"-Example_4\"",
                "assert fix_spaces(\"Example   7   has   spaces\") == \"Example-7-has-spaces\"",
                "assert fix_spaces(\"     \") == \"-\""
            ],
            "failed_tests": [
                "assert fix_spaces(\"Example 8 has  some   spaces\") == \"Example_8_has_some-spaces\" (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/141",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert file_name_check(\"example.txt\") == 'Yes'",
                "assert file_name_check(\"ex@mple.txt\") == 'Yes'",
                "assert file_name_check(\"example.v1.txt\") == 'No'",
                "assert file_name_check(\"example.TXT\") == 'No'"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/142",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert sum_squares([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 0, \"The sum should be 0 when all elements are 0, regardless of squaring or cubing.\""
            ],
            "failed_tests": [
                "assert sum_squares([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 1030, \"The sum should correctly handle a longer list with multiple squaring and cubing conditions.\" (AssertionError: The sum should correctly handle a longer list with multiple squaring and cubing conditions.)",
                "assert sum_squares([1, 2, 3, 4]) == 10, \"The sum should include the square of the value at index 3.\" (AssertionError: The sum should include the square of the value at index 3.)",
                "assert sum_squares([1, 2, 5, 7]) == 15, \"The sum should be the same as the input list when no index is a multiple of 3 or 4.\" (AssertionError: The sum should be the same as the input list when no index is a multiple of 3 or 4.)"
            ]
        }
    },
    {
        "task_id": "HumanEval/143",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert words_in_sentence(\"This is a test\") == \"is\""
            ],
            "failed_tests": [
                "assert words_in_sentence(\"Hello world program\") == \"world\" (AssertionError: )",
                "assert words_in_sentence(\"go to gym\") == \"go to\" (AssertionError: )",
                "assert words_in_sentence(\"a an the\") == \"\" (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/144",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert simplify(\"2/3\", \"2/3\") == False",
                "assert simplify(\"1000000/1\", \"1/1000000\") == True",
                "assert simplify(\"1/1000000\", \"999999/1\") == False",
                "assert simplify(\"1/6\", \"2/1\") == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/145",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert order_by_points([5]) == [5], \"Test with single integer failed\"",
                "assert order_by_points([]) == [], \"Test with an empty list failed\""
            ],
            "failed_tests": [
                "assert order_by_points([1, -2, 3, -4]) == [1, -2, 3, -4], \"Test with mixed positive and negative numbers failed\" (AssertionError: Test with mixed positive and negative numbers failed)",
                "assert order_by_points([111, 22, 3]) == [3, 22, 111], \"Test with different sums of digits failed\" (AssertionError: Test with different sums of digits failed)"
            ]
        }
    },
    {
        "task_id": "HumanEval/146",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert specialFilter([999999999999999999]) == 1",
                "assert specialFilter([-11, -13, -15, -17, -19]) == 0",
                "assert specialFilter([11, 13, 35, 57, 79, 101]) == 6"
            ],
            "failed_tests": [
                "assert specialFilter(list(range(1, 10000))) == 0 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/147",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert get_max_triples(5) == 1",
                "assert get_max_triples(6) > 1",
                "assert get_max_triples(1) == 0",
                "assert isinstance(get_max_triples(10), int)"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/148",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert bf(\"Mercury\", \"Venus\") == (), \"Test with Mercury and Venus, expecting an empty tuple since there are no planets between them.\"",
                "assert bf(\"Pluto\", \"Xandar\") == (), \"Test with both planets being invalid, expecting an empty tuple.\"",
                "assert bf(\"Pluto\", \"Mars\") == (), \"Test with an invalid planet (Pluto) and a valid planet (Mars), expecting an empty tuple.\""
            ],
            "failed_tests": [
                "assert bf(\"Neptune\", \"Mercury\") == (), \"Test with Neptune and Mercury, expecting an empty tuple since Neptune is the last planet and Mercury is the first.\" (AssertionError: Test with Neptune and Mercury, expecting an empty tuple since Neptune is the last planet and Mercury is the first.)"
            ]
        }
    },
    {
        "task_id": "HumanEval/149",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert sorted_list_sum([\"ba\", \"ab\", \"ca\", \"ac\"]) == [\"ab\", \"ac\", \"ba\", \"ca\"]",
                "assert sorted_list_sum([\"a\", \"abc\", \"abcde\"]) == []",
                "assert sorted_list_sum([\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"]) == [\"ab\", \"abcd\"]",
                "assert sorted_list_sum([\"a\", \"ab\", \"ab\", \"abc\", \"abcd\", \"abcd\"]) == [\"ab\", \"ab\", \"abcd\", \"abcd\"]"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/150",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert x_or_y(2, 10, 20) == 10",
                "assert x_or_y(13, 0, 1) == 0",
                "assert x_or_y(1, 70, 80) == 80",
                "assert x_or_y(15, 8, 5) == 5"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/151",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert double_the_difference([1, 5, 7]) == 1**2 + 5**2 + 7**2",
                "assert double_the_difference(list(range(1, 11))) == sum(x**2 for x in range(1, 11) if x % 2 != 0)",
                "assert double_the_difference([0]) == 0",
                "assert double_the_difference([2, 4, 6]) == 0"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/152",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert compare([5], [5]) == [0], \"Single element arrays with correct guess\"",
                "assert compare([], []) == [], \"Empty arrays\"",
                "assert compare([10, 20, 30, 40, 50], [10, 25, 30, 45, 50]) == [0, 5, 0, 5, 0], \"Mix of correct and incorrect guesses\"",
                "assert compare([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [0, 0, 0, 0, 0], \"All guesses are correct\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/153",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert Strongest_Extension('Vehicle', ['wheels']) == 'Vehicle.wheels'",
                "assert Strongest_Extension('Fruit', ['Apple', 'Banana', 'Cherry']) == 'Fruit.Apple'",
                "assert Strongest_Extension('Car', ['SUV', 'sedan', 'Coupe']) == 'Car.SUV'"
            ],
            "failed_tests": [
                "assert Strongest_Extension('Device', ['Android', 'iOS', 'Windows']) == 'Device.Android' (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/154",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert cycpattern_check(\"rotation\", \"ationrot\") == True",
                "assert cycpattern_check(\"hi\", \"hello\") == False",
                "assert cycpattern_check(\"a\", \"\") == True",
                "assert cycpattern_check(\"efef\", \"eeff\") == False"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/155",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert even_odd_count(3333) == (0, 4)",
                "assert even_odd_count(24680) == (5, 0)",
                "assert even_odd_count(-12345) == (2, 3)",
                "assert even_odd_count(0) == (1, 0)"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/156",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert int_to_mini_roman(3888) == 'mmmdccclxxxviii', \"Failed on a number that includes all symbols\"",
                "assert int_to_mini_roman(7) == 'vii', \"Failed on a number that includes a 7\"",
                "assert int_to_mini_roman(3) == 'iii', \"Failed on a number that results in a repeated numeral\"",
                "assert int_to_mini_roman(500) == 'd', \"Failed on the number that is half of the upper limit\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/157",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert right_angle_triangle(10, 10, 14) == False",
                "assert right_angle_triangle(6, 8, 10) == True",
                "assert right_angle_triangle(1.5, 2.5, 3.5) == False",
                "assert right_angle_triangle(300, 400, 500) == True"
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/158",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert find_max([\"123\", \"@@@\", \"abc\"]) == \"123\", \"Test with numbers and special characters failed.\"",
                "assert find_max([\"Name\", \"Of\", \"String\"]) == \"String\", \"Test with mixed case strings failed.\""
            ],
            "failed_tests": [
                "assert find_max([\"\u00f1ame\", \"\u00f6f\", \"str\u00efng\"]) == \"\u00f1ame\", \"Test with Unicode characters failed.\" (AssertionError: Test with Unicode characters failed.)",
                "assert find_max(large_list) == \"word0\", \"Test with a very large list of strings failed.\" (NameError: name 'large_list' is not defined)"
            ]
        }
    },
    {
        "task_id": "HumanEval/159",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert eat(0, 0, 0) == [0, 0], \"Test failed on lower bound edge case.\"",
                "assert eat(500, 500, 1000) == [1000, 500], \"Test failed with large numbers and sufficient stock.\"",
                "assert eat(1000, 500, 1000) == [1500, 500], \"Test failed on upper bound edge case with surplus remaining.\"",
                "assert eat(800, 400, 100) == [900, 0], \"Test failed with large numbers and insufficient stock.\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/160",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert do_algebra(['*', '*', '*'], [2, 3, 4, 5]) == 120",
                "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9",
                "assert do_algebra(['*'], [3, 4]) == 12"
            ],
            "failed_tests": [
                "assert do_algebra(['+', '-', '*', '//'], [1000, 0, 100, 10, 2]) == 450 (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/161",
        "is_solved": true,
        "test_results": {
            "passed_tests": [
                "assert solve(\"abcd\") == \"ABCD\"",
                "assert solve(\"AbCd\") == \"aBcD\"",
                "assert solve(\"ABCD\") == \"abcd\"",
                "assert solve(\"1\") == \"1\""
            ],
            "failed_tests": []
        }
    },
    {
        "task_id": "HumanEval/162",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert string_to_md5('123') == '202cb962ac59075b964b07152d234b70'",
                "assert string_to_md5(' ') == '7215ee9c7d9dc229d2921a40e899ec5f'"
            ],
            "failed_tests": [
                "assert string_to_md5('one hundred') == '9a0364b9e99bb480dd25e1f0284c8555' (AssertionError: )",
                "assert string_to_md5('a'*1000) == '02a0e62ed2a9a9e6af908b6e3e5208a9' (AssertionError: )"
            ]
        }
    },
    {
        "task_id": "HumanEval/163",
        "is_solved": false,
        "test_results": {
            "passed_tests": [
                "assert generate_integers(3, 8) == [4, 6, 8]",
                "assert generate_integers(1, 10) == [2, 4, 6, 8]"
            ],
            "failed_tests": [
                "assert generate_integers(1000000, 1000010) == [1000000, 1000002, 1000004, 1000006, 1000008, 1000010] (AssertionError: )",
                "assert generate_integers(-5, 5) == [] (AssertionError: )"
            ]
        }
    }
]